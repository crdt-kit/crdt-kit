// ============================================================================
// AUTO-GENERATED by crdt-codegen -- DO NOT EDIT
//
// This file was generated from a crdt-schema.toml definition.
// Any manual changes will be overwritten on the next `crdt generate` run.
//
// To modify this code, edit the schema file and re-run:
//   crdt generate --schema crdt-schema.toml
// ============================================================================

#![allow(dead_code, unused_imports)]

use crdt_store::{CrdtDb, DbError, StateStore};

use super::super::models::Task;
use super::traits::TaskRepository;

/// Repository adapter for Task entities backed by `CrdtDb<S>`.
///
/// This is the "adapter" in hexagonal architecture. It implements
/// `TaskRepository` using the CRDT-aware versioned store.
pub struct TaskRepositoryAccess<'a, S: StateStore> {
    db: &'a mut CrdtDb<S>,
}

impl<'a, S: StateStore> TaskRepositoryAccess<'a, S> {
    /// Create a new repository accessor with a mutable reference to the database.
    pub fn new(db: &'a mut CrdtDb<S>) -> Self {
        Self { db }
    }
}

impl<S: StateStore> TaskRepository for TaskRepositoryAccess<'_, S> {
    type Error = DbError<S::Error>;

    fn get(&mut self, id: &str) -> Result<Option<Task>, Self::Error> {
        self.db.load_ns("tasks", id)
    }

    fn save(&mut self, id: &str, entity: &Task) -> Result<(), Self::Error> {
        self.db.save_ns("tasks", id, entity)
    }

    fn delete(&mut self, id: &str) -> Result<(), Self::Error> {
        self.db.delete_ns("tasks", id)
    }

    fn list(&mut self) -> Result<Vec<(String, Task)>, Self::Error> {
        let keys = self.db.list_keys_ns("tasks")?;
        let mut result = Vec::new();
        for key in keys {
            if let Some(entity) = self.db.load_ns("tasks", &key)? {
                result.push((key, entity));
            }
        }
        Ok(result)
    }

    fn exists(&self, id: &str) -> Result<bool, Self::Error> {
        self.db.exists_ns("tasks", id)
    }

    fn find_by_project_id(&mut self, val: &str) -> Result<Vec<(String, Task)>, Self::Error> {
        let all = self.list()?;
        Ok(all
            .into_iter()
            .filter(|(_, e)| e.project_id == val)
            .collect())
    }
}
